push_constant push
{
    f4 offset_and_time;
    alias (offset, offset_and_time.xy)
    alias (local_time, offset_and_time.z)
    u4 meta;
    alias (ui_mark, meta.x)
};

vertex_attribute_container vertex
{
    f2 position;
};

struct text_palette_entry
{
    f4 color_main;
    f4 color_outline;
    f4 cos_anim_color;
    f4 color_hovered;
    f4 color_down;
    u1 color_table_multiplier_index;
};

set_material read_only_storage_buffer text_setup
{
    f1 cos_anim_period;
    f1 glyph_read_time;
    text_palette_entry... text_palette;
};

constant text_palette_mask = 0xff;
constant text_outline_flag = 1u << 8u;
constant text_cos_anim_flag = 1u << 9u;
constant text_reading_anim_flag = 1u << 10u;
constant text_color_table_flag = 1u << 11u;

f4 calculate_text_color (in u1 mark, in u1 read_index, in u1 ui_mark)
{
    u1 text_palette_index = mark & text_palette_mask;
    alias (text_palette, text_setup.text_palette[text_palette_index])
    f4 color = text_palette.color_main;
    
    if ((ui_mark & ui_mark_default_flag_hovered) != 0u)
    {
        color = text_palette.color_hovered;
    }
    
    if ((ui_mark & ui_mark_default_flag_down) != 0u)
    {
        color = text_palette.color_down;
    }
    
    if ((mark & text_cos_anim_flag) != 0u)
    {
       f1 phase = 2.0 * pi() * fract_f1 (push.local_time / text_setup.cos_anim_period);
       f1 modifier = cos_f1(phase) * 0.5 + 0.5;
       color = mix_f4 (text_palette.cos_anim_color, color, f4 {modifier});
    }
    
    if ((mark & text_color_table_flag) != 0u)
    {
        color = color * color_table.values[text_palette.color_table_multiplier_index];
    }
    
    if ((mark & text_reading_anim_flag) != 0u)
    {
        f1 time_to_get_here = text_setup.glyph_read_time * f1 {read_index};
        if (time_to_get_here > push.local_time)
        {
            color = f4 {0.0};
        }
    }
    
    return color;
}
